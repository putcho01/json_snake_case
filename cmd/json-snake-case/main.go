package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
)

var (
	typeNames      = flag.String("type", "", "type名のリスト")
	outputFilePath = flag.String("out", "", "出力するGoのファイル名")
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("json_snake: ")
	flag.Parse()

	if len(*typeNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	types := strings.Split(*typeNames, ",")
	if len(types) == 0 {
		log.Fatal("no types specified")
	}

	// Parse package from current directory
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("parse package error: %v", err)
	}

	if len(pkgs) != 1 {
		log.Fatal("expected exactly one package")
	}

	for _, p := range pkgs {
		for fileName, file := range p.Files {
			astFile := &File{
				Name:    fileName,
				AstFile: file,
			}

			// Inspect AST for type declarations
			ast.Inspect(astFile.AstFile, func(n ast.Node) bool {
				genDecl, ok := n.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					return true
				}

				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}

					typeName := typeSpec.Name.Name
					if !contains(types, typeName) {
						continue
					}

					// Generate struct with JSON tags using text/template
					genStructCode(typeName, structType)
				}

				return false
			})
		}
	}
}

type File struct {
	Name    string
	AstFile *ast.File
}

// Utility functions for JSON tag generation
func toSnakeCase(str string) string {
	var builder strings.Builder
	for i, r := range str {
		if unicode.IsUpper(r) {
			if i > 0 {
				// Add underscore if not the first uppercase letter
				// and the previous character is not already an underscore.
				previous := rune(str[i-1])
				if !unicode.IsUpper(previous) && previous != '_' {
					builder.WriteRune('_')
				}
			}
			builder.WriteRune(unicode.ToLower(r))
		} else {
			builder.WriteRune(r)
		}
	}
	return builder.String()
}

func contains(list []string, str string) bool {
	for _, item := range list {
		if item == str {
			return true
		}
	}
	return false
}

// Generate struct code using text/template
func genStructCode(typeName string, structType *ast.StructType) {
	// Define template for struct
	const structTemplate = `
// Code generated by "json_snake_case"; DO NOT EDIT.

package {{ .PackageName }}

type {{ .TypeName }}Json struct {
{{ range .Fields }}{{ .FieldName }} string ` + "`json:\"{{ .JSONTag }}\"`" + `
{{ end }}
}
`

	// Prepare data for template
	data := struct {
		PackageName string
		TypeName    string
		Fields      []struct {
			FieldName string
			JSONTag   string
		}
	}{
		PackageName: "main", // Change this to your package name
		TypeName:    typeName,
		Fields: []struct {
			FieldName string
			JSONTag   string
		}{},
	}

	// Populate fields with struct fields and JSON tags
	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		fieldName := field.Names[0].Name
		jsonTag := toSnakeCase(fieldName)
		data.Fields = append(data.Fields, struct {
			FieldName string
			JSONTag   string
		}{FieldName: fieldName, JSONTag: jsonTag})
	}

	// Execute template
	var buf bytes.Buffer
	tmpl := template.Must(template.New("struct").Parse(structTemplate))
	err := tmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("failed to execute template: %v", err)
	}

	// Format generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("failed to format source code: %v", err)
	}

	outputFile, err := os.Create(*outputFilePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create file: %v\n", err)
		os.Exit(1)
	}
	defer outputFile.Close()

	// Write the formatted code to the file
	_, err = outputFile.Write(formatted)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to write file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated file: %s\n", *outputFilePath)
}
